<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neural Network library: Класс cv::SparseMat</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Neural Network library
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">Small lib for neural networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcv_1_1_sparse_mat.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Классы</a> &#124;
<a href="#pub-types">Открытые типы</a> &#124;
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="#pub-attribs">Открытые атрибуты</a> &#124;
<a href="classcv_1_1_sparse_mat-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Класс cv::SparseMat<div class="ingroups"><a class="el" href="group__core.html">Core functionality</a> &raquo; <a class="el" href="group__core__basic.html">Basic structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="classcv_1_1_sparse_mat.html" title="The class SparseMat represents multi-dimensional sparse numerical arrays.">SparseMat</a> represents multi-dimensional sparse numerical arrays.  
 <a href="classcv_1_1_sparse_mat.html#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="core_2mat_8hpp_source.html">mat.hpp</a>&gt;</code></p>

<p>Производные классы:<a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_&lt; _Tp &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Классы</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the sparse matrix header  <a href="structcv_1_1_sparse_mat_1_1_hdr.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse matrix node - element of a hash table  <a href="structcv_1_1_sparse_mat_1_1_node.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Открытые типы</h2></td></tr>
<tr class="memitem:ac1661965352d76357d8ecd5cb496026e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classcv_1_1_sparse_mat.html#ac1661965352d76357d8ecd5cb496026ea14d02d4adbcb5fa71d1922ceda241e8a">MAGIC_VAL</a> =0x42FD0000
, <a class="el" href="classcv_1_1_sparse_mat.html#ac1661965352d76357d8ecd5cb496026eabe1aff4cd2b540afd5a3f4ffca3bd9a2">MAX_DIM</a> =32
, <a class="el" href="classcv_1_1_sparse_mat.html#ac1661965352d76357d8ecd5cb496026ea28ca477c8ed1afabd0da753827149eeb">HASH_SCALE</a> =0x5bd1e995
, <a class="el" href="classcv_1_1_sparse_mat.html#ac1661965352d76357d8ecd5cb496026ea79cfd2c6ddc2c192623e8426429d27d1">HASH_BIT</a> =0x80000000
 }</td></tr>
<tr class="separator:ac1661965352d76357d8ecd5cb496026e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa766accd9ac415bea90019010f58cac6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aa766accd9ac415bea90019010f58cac6">iterator</a></td></tr>
<tr class="separator:aa766accd9ac415bea90019010f58cac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7803d5c41eef808081903167d3a263"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4f7803d5c41eef808081903167d3a263">const_iterator</a></td></tr>
<tr class="separator:a4f7803d5c41eef808081903167d3a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:a9b5f1214a43144122b158c354a93e338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">SparseMat</a> ()</td></tr>
<tr class="memdesc:a9b5f1214a43144122b158c354a93e338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various <a class="el" href="classcv_1_1_sparse_mat.html" title="The class SparseMat represents multi-dimensional sparse numerical arrays.">SparseMat</a> constructors.  <a href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">Подробнее...</a><br /></td></tr>
<tr class="separator:a9b5f1214a43144122b158c354a93e338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62224fe4fbdc6134d80861a150e01b58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a62224fe4fbdc6134d80861a150e01b58">SparseMat</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> <a class="el" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a>, const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *_sizes, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> _type)</td></tr>
<tr class="separator:a62224fe4fbdc6134d80861a150e01b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753add6192d4355c04e6e3594ab97b49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a753add6192d4355c04e6e3594ab97b49">SparseMat</a> (const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m)</td></tr>
<tr class="separator:a753add6192d4355c04e6e3594ab97b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9432a94bda00c7fd2103bcd57654d03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af9432a94bda00c7fd2103bcd57654d03">SparseMat</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr class="separator:af9432a94bda00c7fd2103bcd57654d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1903162ea8588b8dd0c4421824f8dd9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a1903162ea8588b8dd0c4421824f8dd9d">~SparseMat</a> ()</td></tr>
<tr class="memdesc:a1903162ea8588b8dd0c4421824f8dd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the destructor  <a href="classcv_1_1_sparse_mat.html#a1903162ea8588b8dd0c4421824f8dd9d">Подробнее...</a><br /></td></tr>
<tr class="separator:a1903162ea8588b8dd0c4421824f8dd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c0f1ec1d3ffc20305bc4d1747b741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a144c0f1ec1d3ffc20305bc4d1747b741">operator=</a> (const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m)</td></tr>
<tr class="memdesc:a144c0f1ec1d3ffc20305bc4d1747b741"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator. This is O(1) operation, i.e. no data is copied  <a href="classcv_1_1_sparse_mat.html#a144c0f1ec1d3ffc20305bc4d1747b741">Подробнее...</a><br /></td></tr>
<tr class="separator:a144c0f1ec1d3ffc20305bc4d1747b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e634f2d73a077444df4395e50821129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a9e634f2d73a077444df4395e50821129">operator=</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr class="memdesc:a9e634f2d73a077444df4395e50821129"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to the corresponding constructor  <a href="classcv_1_1_sparse_mat.html#a9e634f2d73a077444df4395e50821129">Подробнее...</a><br /></td></tr>
<tr class="separator:a9e634f2d73a077444df4395e50821129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230a36b59925a5e300a703ae1186856b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a230a36b59925a5e300a703ae1186856b">clone</a> () const <a class="el" href="group__core__utils.html#ga1a1bf6728a93cfa692a110252c252d03">CV_NODISCARD</a></td></tr>
<tr class="memdesc:a230a36b59925a5e300a703ae1186856b"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates full copy of the matrix  <a href="classcv_1_1_sparse_mat.html#a230a36b59925a5e300a703ae1186856b">Подробнее...</a><br /></td></tr>
<tr class="separator:a230a36b59925a5e300a703ae1186856b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d9fb50fa768fd20e9f11b003906133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a18d9fb50fa768fd20e9f11b003906133">copyTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m) const</td></tr>
<tr class="memdesc:a18d9fb50fa768fd20e9f11b003906133"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies all the data to the destination matrix. All the previous content of m is erased  <a href="classcv_1_1_sparse_mat.html#a18d9fb50fa768fd20e9f11b003906133">Подробнее...</a><br /></td></tr>
<tr class="separator:a18d9fb50fa768fd20e9f11b003906133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b077b6ec96d3aa588ef32e63cd7f7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6b077b6ec96d3aa588ef32e63cd7f7f5">copyTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m) const</td></tr>
<tr class="memdesc:a6b077b6ec96d3aa588ef32e63cd7f7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to dense matrix.  <a href="classcv_1_1_sparse_mat.html#a6b077b6ec96d3aa588ef32e63cd7f7f5">Подробнее...</a><br /></td></tr>
<tr class="separator:a6b077b6ec96d3aa588ef32e63cd7f7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577ea9bbc02ffcf195df6d96f9c9650c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a577ea9bbc02ffcf195df6d96f9c9650c">convertTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> rtype, double <a class="el" href="group__imgproc__c.html#ga75620528cfc7d5f1288004fa760804ee">alpha</a>=1) const</td></tr>
<tr class="memdesc:a577ea9bbc02ffcf195df6d96f9c9650c"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type  <a href="classcv_1_1_sparse_mat.html#a577ea9bbc02ffcf195df6d96f9c9650c">Подробнее...</a><br /></td></tr>
<tr class="separator:a577ea9bbc02ffcf195df6d96f9c9650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668825b1d0bb87a075cc2382692093b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a668825b1d0bb87a075cc2382692093b7">convertTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> rtype, double <a class="el" href="group__imgproc__c.html#ga75620528cfc7d5f1288004fa760804ee">alpha</a>=1, double <a class="el" href="group__core__c.html#ga4bf45595b7df91ad095c49cf02ddee05">beta</a>=0) const</td></tr>
<tr class="memdesc:a668825b1d0bb87a075cc2382692093b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.  <a href="classcv_1_1_sparse_mat.html#a668825b1d0bb87a075cc2382692093b7">Подробнее...</a><br /></td></tr>
<tr class="separator:a668825b1d0bb87a075cc2382692093b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae102ac11f15a875d9b689575d585d21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ae102ac11f15a875d9b689575d585d21f">assignTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> <a class="el" href="classcv_1_1_sparse_mat.html#a3331bffc1409d61631d223169a950b25">type</a>=-1) const</td></tr>
<tr class="separator:ae102ac11f15a875d9b689575d585d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2713a5ec1fb025c9ff4014a53e68c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#adf2713a5ec1fb025c9ff4014a53e68c6">create</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> <a class="el" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a>, const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *_sizes, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> _type)</td></tr>
<tr class="memdesc:adf2713a5ec1fb025c9ff4014a53e68c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reallocates sparse matrix.  <a href="classcv_1_1_sparse_mat.html#adf2713a5ec1fb025c9ff4014a53e68c6">Подробнее...</a><br /></td></tr>
<tr class="separator:adf2713a5ec1fb025c9ff4014a53e68c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa705d84961513f6e0b0066ec245a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e">clear</a> ()</td></tr>
<tr class="memdesc:a2fa705d84961513f6e0b0066ec245a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets all the sparse matrix elements to 0, which means clearing the hash table.  <a href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e">Подробнее...</a><br /></td></tr>
<tr class="separator:a2fa705d84961513f6e0b0066ec245a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d03d3c19ccd8cd5653b3b7375bb68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a8d1d03d3c19ccd8cd5653b3b7375bb68">addref</a> ()</td></tr>
<tr class="memdesc:a8d1d03d3c19ccd8cd5653b3b7375bb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">manually increments the reference counter to the header.  <a href="classcv_1_1_sparse_mat.html#a8d1d03d3c19ccd8cd5653b3b7375bb68">Подробнее...</a><br /></td></tr>
<tr class="separator:a8d1d03d3c19ccd8cd5653b3b7375bb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4c162afd8cc809d23bd0fe9b38ead7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">release</a> ()</td></tr>
<tr class="separator:a3f4c162afd8cc809d23bd0fe9b38ead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42f343f4f3d5bc974db1eca57417150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af42f343f4f3d5bc974db1eca57417150">elemSize</a> () const</td></tr>
<tr class="memdesc:af42f343f4f3d5bc974db1eca57417150"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to the old-style representation; all the elements are copied.  <a href="classcv_1_1_sparse_mat.html#af42f343f4f3d5bc974db1eca57417150">Подробнее...</a><br /></td></tr>
<tr class="separator:af42f343f4f3d5bc974db1eca57417150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3564e3c77b19ac1104dbe924973dd288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3564e3c77b19ac1104dbe924973dd288">elemSize1</a> () const</td></tr>
<tr class="memdesc:a3564e3c77b19ac1104dbe924973dd288"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classcv_1_1_sparse_mat.html#af42f343f4f3d5bc974db1eca57417150" title="converts sparse matrix to the old-style representation; all the elements are copied.">elemSize()</a>/channels()  <a href="classcv_1_1_sparse_mat.html#a3564e3c77b19ac1104dbe924973dd288">Подробнее...</a><br /></td></tr>
<tr class="separator:a3564e3c77b19ac1104dbe924973dd288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3331bffc1409d61631d223169a950b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3331bffc1409d61631d223169a950b25">type</a> () const</td></tr>
<tr class="memdesc:a3331bffc1409d61631d223169a950b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns type of sparse matrix elements  <a href="classcv_1_1_sparse_mat.html#a3331bffc1409d61631d223169a950b25">Подробнее...</a><br /></td></tr>
<tr class="separator:a3331bffc1409d61631d223169a950b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40e39e851f00341f1df57cb482429dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ae40e39e851f00341f1df57cb482429dc">depth</a> () const</td></tr>
<tr class="memdesc:ae40e39e851f00341f1df57cb482429dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the depth of sparse matrix elements  <a href="classcv_1_1_sparse_mat.html#ae40e39e851f00341f1df57cb482429dc">Подробнее...</a><br /></td></tr>
<tr class="separator:ae40e39e851f00341f1df57cb482429dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b3b831a74b2071f8741ee873e925f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#acb6b3b831a74b2071f8741ee873e925f">channels</a> () const</td></tr>
<tr class="memdesc:acb6b3b831a74b2071f8741ee873e925f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of channels  <a href="classcv_1_1_sparse_mat.html#acb6b3b831a74b2071f8741ee873e925f">Подробнее...</a><br /></td></tr>
<tr class="separator:acb6b3b831a74b2071f8741ee873e925f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eac830987646a4792815ad4e717c3e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a65eac830987646a4792815ad4e717c3e">size</a> () const</td></tr>
<tr class="memdesc:a65eac830987646a4792815ad4e717c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the array of sizes, or NULL if the matrix is not allocated  <a href="classcv_1_1_sparse_mat.html#a65eac830987646a4792815ad4e717c3e">Подробнее...</a><br /></td></tr>
<tr class="separator:a65eac830987646a4792815ad4e717c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe9c986b3cf0240c68ce985df334c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4fe9c986b3cf0240c68ce985df334c17">size</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i) const</td></tr>
<tr class="memdesc:a4fe9c986b3cf0240c68ce985df334c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of i-th matrix dimension (or 0)  <a href="classcv_1_1_sparse_mat.html#a4fe9c986b3cf0240c68ce985df334c17">Подробнее...</a><br /></td></tr>
<tr class="separator:a4fe9c986b3cf0240c68ce985df334c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1779da985ecb9cd570e0dd71a49b6aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a> () const</td></tr>
<tr class="memdesc:a1779da985ecb9cd570e0dd71a49b6aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the matrix dimensionality  <a href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">Подробнее...</a><br /></td></tr>
<tr class="separator:a1779da985ecb9cd570e0dd71a49b6aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cd6ef01802341dda3e8b75af5933f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad0cd6ef01802341dda3e8b75af5933f0">nzcount</a> () const</td></tr>
<tr class="memdesc:ad0cd6ef01802341dda3e8b75af5933f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of non-zero elements (=the number of hash table nodes)  <a href="classcv_1_1_sparse_mat.html#ad0cd6ef01802341dda3e8b75af5933f0">Подробнее...</a><br /></td></tr>
<tr class="separator:ad0cd6ef01802341dda3e8b75af5933f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae882e4ed31b4cc76b19cd67d84e854b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ae882e4ed31b4cc76b19cd67d84e854b1">hash</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0) const</td></tr>
<tr class="memdesc:ae882e4ed31b4cc76b19cd67d84e854b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (1D case)  <a href="classcv_1_1_sparse_mat.html#ae882e4ed31b4cc76b19cd67d84e854b1">Подробнее...</a><br /></td></tr>
<tr class="separator:ae882e4ed31b4cc76b19cd67d84e854b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9aba486fd7e4fc2b1c80bc54844ac23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aa9aba486fd7e4fc2b1c80bc54844ac23">hash</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1) const</td></tr>
<tr class="memdesc:aa9aba486fd7e4fc2b1c80bc54844ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (2D case)  <a href="classcv_1_1_sparse_mat.html#aa9aba486fd7e4fc2b1c80bc54844ac23">Подробнее...</a><br /></td></tr>
<tr class="separator:aa9aba486fd7e4fc2b1c80bc54844ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681b6dafd842a95589cb82ed790279c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a681b6dafd842a95589cb82ed790279c9">hash</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i2) const</td></tr>
<tr class="memdesc:a681b6dafd842a95589cb82ed790279c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (3D case)  <a href="classcv_1_1_sparse_mat.html#a681b6dafd842a95589cb82ed790279c9">Подробнее...</a><br /></td></tr>
<tr class="separator:a681b6dafd842a95589cb82ed790279c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4f02569b2b2f183903112435a13f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a5c4f02569b2b2f183903112435a13f83">hash</a> (const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *<a class="el" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>) const</td></tr>
<tr class="memdesc:a5c4f02569b2b2f183903112435a13f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (nD case)  <a href="classcv_1_1_sparse_mat.html#a5c4f02569b2b2f183903112435a13f83">Подробнее...</a><br /></td></tr>
<tr class="separator:a5c4f02569b2b2f183903112435a13f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ff041a2a3771613847b94c761ab1f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">erase</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:ad4ff041a2a3771613847b94c761ab1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (2D case)  <a href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">Подробнее...</a><br /></td></tr>
<tr class="separator:ad4ff041a2a3771613847b94c761ab1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00d2c0c7bff3c631d1ac43fe1be45cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ab00d2c0c7bff3c631d1ac43fe1be45cd">erase</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i2, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:ab00d2c0c7bff3c631d1ac43fe1be45cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (3D case)  <a href="classcv_1_1_sparse_mat.html#ab00d2c0c7bff3c631d1ac43fe1be45cd">Подробнее...</a><br /></td></tr>
<tr class="separator:ab00d2c0c7bff3c631d1ac43fe1be45cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f64485a3f47ba79847a3fdf349b9943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6f64485a3f47ba79847a3fdf349b9943">erase</a> (const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *<a class="el" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a6f64485a3f47ba79847a3fdf349b9943"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (nD case)  <a href="classcv_1_1_sparse_mat.html#a6f64485a3f47ba79847a3fdf349b9943">Подробнее...</a><br /></td></tr>
<tr class="separator:a6f64485a3f47ba79847a3fdf349b9943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cef837db3fd9aabef3abb57ae19a1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a71cef837db3fd9aabef3abb57ae19a1b">end</a> ()</td></tr>
<tr class="memdesc:a71cef837db3fd9aabef3abb57ae19a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sparse matrix iterator at the matrix end  <a href="classcv_1_1_sparse_mat.html#a71cef837db3fd9aabef3abb57ae19a1b">Подробнее...</a><br /></td></tr>
<tr class="separator:a71cef837db3fd9aabef3abb57ae19a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3e2d01ec6a363488097ae2b0b3c124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4d3e2d01ec6a363488097ae2b0b3c124">end</a> () const</td></tr>
<tr class="memdesc:a4d3e2d01ec6a363488097ae2b0b3c124"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the read-only sparse matrix iterator at the matrix end  <a href="classcv_1_1_sparse_mat.html#a4d3e2d01ec6a363488097ae2b0b3c124">Подробнее...</a><br /></td></tr>
<tr class="separator:a4d3e2d01ec6a363488097ae2b0b3c124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe2ca854bcafa54cb371146523c7e36"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4fe2ca854bcafa54cb371146523c7e36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4fe2ca854bcafa54cb371146523c7e36">end</a> ()</td></tr>
<tr class="memdesc:a4fe2ca854bcafa54cb371146523c7e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the typed sparse matrix iterator at the matrix end  <a href="classcv_1_1_sparse_mat.html#a4fe2ca854bcafa54cb371146523c7e36">Подробнее...</a><br /></td></tr>
<tr class="separator:a4fe2ca854bcafa54cb371146523c7e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac004c4119d6e77bfa95e803d9a7dd5fd"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ac004c4119d6e77bfa95e803d9a7dd5fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac004c4119d6e77bfa95e803d9a7dd5fd">end</a> () const</td></tr>
<tr class="memdesc:ac004c4119d6e77bfa95e803d9a7dd5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the typed read-only sparse matrix iterator at the matrix end  <a href="classcv_1_1_sparse_mat.html#ac004c4119d6e77bfa95e803d9a7dd5fd">Подробнее...</a><br /></td></tr>
<tr class="separator:ac004c4119d6e77bfa95e803d9a7dd5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ede1a78ef553729dd33f039c1ed50f5"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a0ede1a78ef553729dd33f039c1ed50f5"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a0ede1a78ef553729dd33f039c1ed50f5">value</a> (<a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a0ede1a78ef553729dd33f039c1ed50f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value stored in the sparse martix node  <a href="classcv_1_1_sparse_mat.html#a0ede1a78ef553729dd33f039c1ed50f5">Подробнее...</a><br /></td></tr>
<tr class="separator:a0ede1a78ef553729dd33f039c1ed50f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e257c6ec922968175136de3f572d2f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a39e257c6ec922968175136de3f572d2f"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a39e257c6ec922968175136de3f572d2f">value</a> (const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *n) const</td></tr>
<tr class="memdesc:a39e257c6ec922968175136de3f572d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value stored in the sparse martix node  <a href="classcv_1_1_sparse_mat.html#a39e257c6ec922968175136de3f572d2f">Подробнее...</a><br /></td></tr>
<tr class="separator:a39e257c6ec922968175136de3f572d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499f156a1dc912aae86f1d725fbb9b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a499f156a1dc912aae86f1d725fbb9b77">node</a> (<a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> nidx)</td></tr>
<tr class="separator:a499f156a1dc912aae86f1d725fbb9b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e934620dcbc6248a09e2b8a5760b3f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ab3e934620dcbc6248a09e2b8a5760b3f">node</a> (<a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> nidx) const</td></tr>
<tr class="separator:ab3e934620dcbc6248a09e2b8a5760b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbf3c27ab6d5f90e4d37b1654f90f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#acfbf3c27ab6d5f90e4d37b1654f90f0a">newNode</a> (const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *<a class="el" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> hashval)</td></tr>
<tr class="separator:acfbf3c27ab6d5f90e4d37b1654f90f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adcb69ee679da35f74ea3a78594a692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a5adcb69ee679da35f74ea3a78594a692">removeNode</a> (<a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> hidx, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> nidx, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> previdx)</td></tr>
<tr class="separator:a5adcb69ee679da35f74ea3a78594a692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86523883daef3f618a7ec38fe049edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af86523883daef3f618a7ec38fe049edc">resizeHashTab</a> (<a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> newsize)</td></tr>
<tr class="separator:af86523883daef3f618a7ec38fe049edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a810b96cf23e3cc816e7f99473b81b513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">ptr</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, bool createMissing, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a810b96cf23e3cc816e7f99473b81b513"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (1D case)  <a href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">Подробнее...</a><br /></td></tr>
<tr class="separator:a810b96cf23e3cc816e7f99473b81b513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e7bb6106e6b4608ddbbc394bbf585e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a14e7bb6106e6b4608ddbbc394bbf585e">ptr</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, bool createMissing, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a14e7bb6106e6b4608ddbbc394bbf585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (2D case)  <a href="classcv_1_1_sparse_mat.html#a14e7bb6106e6b4608ddbbc394bbf585e">Подробнее...</a><br /></td></tr>
<tr class="separator:a14e7bb6106e6b4608ddbbc394bbf585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e9b6331a781f1d746e77582bee8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#afa0e9b6331a781f1d746e77582bee8a8">ptr</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i2, bool createMissing, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:afa0e9b6331a781f1d746e77582bee8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (3D case)  <a href="classcv_1_1_sparse_mat.html#afa0e9b6331a781f1d746e77582bee8a8">Подробнее...</a><br /></td></tr>
<tr class="separator:afa0e9b6331a781f1d746e77582bee8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5425bac965f62767f50c7e68a7c452a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a5425bac965f62767f50c7e68a7c452a0">ptr</a> (const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *<a class="el" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>, bool createMissing, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a5425bac965f62767f50c7e68a7c452a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (nD case)  <a href="classcv_1_1_sparse_mat.html#a5425bac965f62767f50c7e68a7c452a0">Подробнее...</a><br /></td></tr>
<tr class="separator:a5425bac965f62767f50c7e68a7c452a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0e1e95540e8cc75976bb4be97dc2203e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a0e1e95540e8cc75976bb4be97dc2203e"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a0e1e95540e8cc75976bb4be97dc2203e">ref</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a0e1e95540e8cc75976bb4be97dc2203e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to the specified element (1D case)  <a href="classcv_1_1_sparse_mat.html#a0e1e95540e8cc75976bb4be97dc2203e">Подробнее...</a><br /></td></tr>
<tr class="separator:a0e1e95540e8cc75976bb4be97dc2203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565a2111e6223af3d3e7d7af2db7588b"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a565a2111e6223af3d3e7d7af2db7588b"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a565a2111e6223af3d3e7d7af2db7588b">ref</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a565a2111e6223af3d3e7d7af2db7588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to the specified element (2D case)  <a href="classcv_1_1_sparse_mat.html#a565a2111e6223af3d3e7d7af2db7588b">Подробнее...</a><br /></td></tr>
<tr class="separator:a565a2111e6223af3d3e7d7af2db7588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8123bdba2899184e4946c82b2ddaa541"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a8123bdba2899184e4946c82b2ddaa541"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a8123bdba2899184e4946c82b2ddaa541">ref</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i2, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a8123bdba2899184e4946c82b2ddaa541"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to the specified element (3D case)  <a href="classcv_1_1_sparse_mat.html#a8123bdba2899184e4946c82b2ddaa541">Подробнее...</a><br /></td></tr>
<tr class="separator:a8123bdba2899184e4946c82b2ddaa541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eeb43c5070301db9cba23bdb45ee11"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a31eeb43c5070301db9cba23bdb45ee11"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a31eeb43c5070301db9cba23bdb45ee11">ref</a> (const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *<a class="el" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0)</td></tr>
<tr class="memdesc:a31eeb43c5070301db9cba23bdb45ee11"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to the specified element (nD case)  <a href="classcv_1_1_sparse_mat.html#a31eeb43c5070301db9cba23bdb45ee11">Подробнее...</a><br /></td></tr>
<tr class="separator:a31eeb43c5070301db9cba23bdb45ee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a64d526ae50a7aceb49b2c5ba3528c859"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a64d526ae50a7aceb49b2c5ba3528c859"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a64d526ae50a7aceb49b2c5ba3528c859">value</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:a64d526ae50a7aceb49b2c5ba3528c859"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (1D case)  <a href="classcv_1_1_sparse_mat.html#a64d526ae50a7aceb49b2c5ba3528c859">Подробнее...</a><br /></td></tr>
<tr class="separator:a64d526ae50a7aceb49b2c5ba3528c859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50920170695fb08a34b4dbfd272b352d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a50920170695fb08a34b4dbfd272b352d"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a50920170695fb08a34b4dbfd272b352d">value</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:a50920170695fb08a34b4dbfd272b352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (2D case)  <a href="classcv_1_1_sparse_mat.html#a50920170695fb08a34b4dbfd272b352d">Подробнее...</a><br /></td></tr>
<tr class="separator:a50920170695fb08a34b4dbfd272b352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34720d97d1db6e1f57ab229fddb5281f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a34720d97d1db6e1f57ab229fddb5281f"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a34720d97d1db6e1f57ab229fddb5281f">value</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i2, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:a34720d97d1db6e1f57ab229fddb5281f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (3D case)  <a href="classcv_1_1_sparse_mat.html#a34720d97d1db6e1f57ab229fddb5281f">Подробнее...</a><br /></td></tr>
<tr class="separator:a34720d97d1db6e1f57ab229fddb5281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af112d88b293cd922392043fd57bb8398"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af112d88b293cd922392043fd57bb8398"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af112d88b293cd922392043fd57bb8398">value</a> (const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *<a class="el" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:af112d88b293cd922392043fd57bb8398"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (nD case)  <a href="classcv_1_1_sparse_mat.html#af112d88b293cd922392043fd57bb8398">Подробнее...</a><br /></td></tr>
<tr class="separator:af112d88b293cd922392043fd57bb8398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af31f0f8c0f55db0640aa8081a593f64e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af31f0f8c0f55db0640aa8081a593f64e"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af31f0f8c0f55db0640aa8081a593f64e">find</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:af31f0f8c0f55db0640aa8081a593f64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (1D case)  <a href="classcv_1_1_sparse_mat.html#af31f0f8c0f55db0640aa8081a593f64e">Подробнее...</a><br /></td></tr>
<tr class="separator:af31f0f8c0f55db0640aa8081a593f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782dd472d4a859a13dc77fca7e4ef8a6"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a782dd472d4a859a13dc77fca7e4ef8a6"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a782dd472d4a859a13dc77fca7e4ef8a6">find</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:a782dd472d4a859a13dc77fca7e4ef8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (2D case)  <a href="classcv_1_1_sparse_mat.html#a782dd472d4a859a13dc77fca7e4ef8a6">Подробнее...</a><br /></td></tr>
<tr class="separator:a782dd472d4a859a13dc77fca7e4ef8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca75a3e5266b78bafcd01dffe75e563d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aca75a3e5266b78bafcd01dffe75e563d"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aca75a3e5266b78bafcd01dffe75e563d">find</a> (<a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i0, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i1, <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> i2, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:aca75a3e5266b78bafcd01dffe75e563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (3D case)  <a href="classcv_1_1_sparse_mat.html#aca75a3e5266b78bafcd01dffe75e563d">Подробнее...</a><br /></td></tr>
<tr class="separator:aca75a3e5266b78bafcd01dffe75e563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a68ed5f9b65fa36c3d209c0dafa24a8"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a6a68ed5f9b65fa36c3d209c0dafa24a8"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6a68ed5f9b65fa36c3d209c0dafa24a8">find</a> (const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *<a class="el" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>, <a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *hashval=0) const</td></tr>
<tr class="memdesc:a6a68ed5f9b65fa36c3d209c0dafa24a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (nD case)  <a href="classcv_1_1_sparse_mat.html#a6a68ed5f9b65fa36c3d209c0dafa24a8">Подробнее...</a><br /></td></tr>
<tr class="separator:a6a68ed5f9b65fa36c3d209c0dafa24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad3913621631f1f3bd6a3a3ef6e667570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad3913621631f1f3bd6a3a3ef6e667570">begin</a> ()</td></tr>
<tr class="memdesc:ad3913621631f1f3bd6a3a3ef6e667570"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sparse matrix iterator at the matrix beginning  <a href="classcv_1_1_sparse_mat.html#ad3913621631f1f3bd6a3a3ef6e667570">Подробнее...</a><br /></td></tr>
<tr class="separator:ad3913621631f1f3bd6a3a3ef6e667570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af371f2cb6952b62ec7ad3b82538d9363"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af371f2cb6952b62ec7ad3b82538d9363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af371f2cb6952b62ec7ad3b82538d9363">begin</a> ()</td></tr>
<tr class="memdesc:af371f2cb6952b62ec7ad3b82538d9363"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sparse matrix iterator at the matrix beginning  <a href="classcv_1_1_sparse_mat.html#af371f2cb6952b62ec7ad3b82538d9363">Подробнее...</a><br /></td></tr>
<tr class="separator:af371f2cb6952b62ec7ad3b82538d9363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106056c6a53a49929da7c52c24945165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a106056c6a53a49929da7c52c24945165">begin</a> () const</td></tr>
<tr class="memdesc:a106056c6a53a49929da7c52c24945165"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the read-only sparse matrix iterator at the matrix beginning  <a href="classcv_1_1_sparse_mat.html#a106056c6a53a49929da7c52c24945165">Подробнее...</a><br /></td></tr>
<tr class="separator:a106056c6a53a49929da7c52c24945165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02b25e131308553618b710e22ca8af1"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ad02b25e131308553618b710e22ca8af1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad02b25e131308553618b710e22ca8af1">begin</a> () const</td></tr>
<tr class="memdesc:ad02b25e131308553618b710e22ca8af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the read-only sparse matrix iterator at the matrix beginning  <a href="classcv_1_1_sparse_mat.html#ad02b25e131308553618b710e22ca8af1">Подробнее...</a><br /></td></tr>
<tr class="separator:ad02b25e131308553618b710e22ca8af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Открытые атрибуты</h2></td></tr>
<tr class="memitem:ad5f261bc8c1330e4e516684861410cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad5f261bc8c1330e4e516684861410cd2">flags</a></td></tr>
<tr class="separator:ad5f261bc8c1330e4e516684861410cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3741ff43acd46b31aace23dee092d85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3741ff43acd46b31aace23dee092d85a">hdr</a></td></tr>
<tr class="separator:a3741ff43acd46b31aace23dee092d85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>The class <a class="el" href="classcv_1_1_sparse_mat.html" title="The class SparseMat represents multi-dimensional sparse numerical arrays.">SparseMat</a> represents multi-dimensional sparse numerical arrays. </p>
<p>Such a sparse array can store elements of any type that <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class">Mat</a> can store. <em>Sparse</em> means that only non-zero elements are stored (though, as a result of operations on a sparse matrix, some of its stored elements can actually become 0. It is up to you to detect such elements and delete them using <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4" title="erases the specified element (2D case)">SparseMat::erase</a> ). The non-zero elements are stored in a hash table that grows when it is filled so that the search time is O(1) in average (regardless of whether element is there or not). Elements can be accessed using the following methods:</p><ul>
<li>Query operations (<a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513" title="returns pointer to the specified element (1D case)">SparseMat::ptr</a> and the higher-level <a class="el" href="classcv_1_1_sparse_mat.html#a0e1e95540e8cc75976bb4be97dc2203e" title="returns reference to the specified element (1D case)">SparseMat::ref</a>, <a class="el" href="classcv_1_1_sparse_mat.html#a64d526ae50a7aceb49b2c5ba3528c859" title="returns value of the specified element (1D case)">SparseMat::value</a> and <a class="el" href="classcv_1_1_sparse_mat.html#af31f0f8c0f55db0640aa8081a593f64e" title="returns pointer to the specified element (1D case)">SparseMat::find</a>), for example: <div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a> = 5;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="classcv_1_1_sparse_mat.html#a65eac830987646a4792815ad4e717c3e">size</a>[5] = {10, 10, 10, 10, 10};</div>
<div class="line"><a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">SparseMat</a> sparse_mat(<a class="code" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a>, <a class="code" href="classcv_1_1_sparse_mat.html#a65eac830987646a4792815ad4e717c3e">size</a>, <a class="code" href="group__core__hal__interface.html#ga4a3def5d72b74bed31f5f8ab7676099c">CV_32F</a>);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 1000; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>[<a class="code" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a>];</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a>; k++)</div>
<div class="line">        <a class="code" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>[k] = rand() % <a class="code" href="classcv_1_1_sparse_mat.html#a65eac830987646a4792815ad4e717c3e">size</a>[k];</div>
<div class="line">    sparse_mat.ref&lt;<span class="keywordtype">float</span>&gt;(<a class="code" href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a>) += 1.f;</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;nnz = &quot;</span> &lt;&lt; sparse_mat.nzcount() &lt;&lt; endl;</div>
<div class="ttc" id="aclasscv_1_1_sparse_mat_html_a1779da985ecb9cd570e0dd71a49b6aca"><div class="ttname"><a href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">cv::SparseMat::dims</a></div><div class="ttdeci">int dims() const</div><div class="ttdoc">returns the matrix dimensionality</div></div>
<div class="ttc" id="aclasscv_1_1_sparse_mat_html_a65eac830987646a4792815ad4e717c3e"><div class="ttname"><a href="classcv_1_1_sparse_mat.html#a65eac830987646a4792815ad4e717c3e">cv::SparseMat::size</a></div><div class="ttdeci">const int * size() const</div><div class="ttdoc">returns the array of sizes, or NULL if the matrix is not allocated</div></div>
<div class="ttc" id="aclasscv_1_1_sparse_mat_html_a9b5f1214a43144122b158c354a93e338"><div class="ttname"><a href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">cv::SparseMat::SparseMat</a></div><div class="ttdeci">SparseMat()</div><div class="ttdoc">Various SparseMat constructors.</div></div>
<div class="ttc" id="agroup__core__c_html_ga5c7c842f447336aa2f10826df65a28b3"><div class="ttname"><a href="group__core__c.html#ga5c7c842f447336aa2f10826df65a28b3">idx</a></div><div class="ttdeci">const int * idx</div><div class="ttdef"><b>Definition:</b> core_c.h:665</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga4a3def5d72b74bed31f5f8ab7676099c"><div class="ttname"><a href="group__core__hal__interface.html#ga4a3def5d72b74bed31f5f8ab7676099c">CV_32F</a></div><div class="ttdeci">#define CV_32F</div><div class="ttdef"><b>Definition:</b> interface.h:78</div></div>
</div><!-- fragment --></li>
<li>Sparse matrix iterators. They are similar to MatIterator but different from <a class="el" href="classcv_1_1_n_ary_mat_iterator.html" title="n-ary multi-dimensional array iterator.">NAryMatIterator</a>. That is, the iteration loop is familiar to STL users: <div class="fragment"><div class="line"><span class="comment">// prints elements of a sparse floating-point matrix</span></div>
<div class="line"><span class="comment">// and the sum of elements.</span></div>
<div class="line">SparseMatConstIterator_&lt;float&gt;</div>
<div class="line">    it = sparse_mat.begin&lt;<span class="keywordtype">float</span>&gt;(),</div>
<div class="line">    it_end = sparse_mat.end&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line"><span class="keywordtype">double</span> s = 0;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a> = sparse_mat.dims();</div>
<div class="line"><span class="keywordflow">for</span>(; it != it_end; ++it)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// print element indices and the element value</span></div>
<div class="line">    <span class="keyword">const</span> SparseMat::Node* n = it.node();</div>
<div class="line">    printf(<span class="stringliteral">&quot;(&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a>; i++)</div>
<div class="line">        printf(<span class="stringliteral">&quot;%d%s&quot;</span>, n-&gt;idx[i], i &lt; <a class="code" href="classcv_1_1_sparse_mat.html#a1779da985ecb9cd570e0dd71a49b6aca">dims</a>-1 ? <span class="stringliteral">&quot;, &quot;</span> : <span class="stringliteral">&quot;)&quot;</span>);</div>
<div class="line">    printf(<span class="stringliteral">&quot;: %g\n&quot;</span>, it.value&lt;<span class="keywordtype">float</span>&gt;());</div>
<div class="line">    s += *it;</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;Element sum is %g\n&quot;</span>, s);</div>
</div><!-- fragment --> If you run this loop, you will notice that elements are not enumerated in a logical order (lexicographical, and so on). They come in the same order as they are stored in the hash table (semi-randomly). You may collect pointers to the nodes and sort them to get the proper ordering. Note, however, that pointers to the nodes may become invalid when you add more elements to the matrix. This may happen due to possible buffer reallocation.</li>
<li>Combination of the above 2 methods when you need to process 2 or more sparse matrices simultaneously. For example, this is how you can compute unnormalized cross-correlation of the 2 floating-point sparse matrices: <div class="fragment"><div class="line"><span class="keywordtype">double</span> cross_corr(<span class="keyword">const</span> <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">SparseMat</a>&amp; a, <span class="keyword">const</span> <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">SparseMat</a>&amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">SparseMat</a> *_a = &amp;a, *_b = &amp;b;</div>
<div class="line">    <span class="comment">// if b contains less elements than a,</span></div>
<div class="line">    <span class="comment">// it is faster to iterate through b</span></div>
<div class="line">    <span class="keywordflow">if</span>(_a-&gt;nzcount() &gt; _b-&gt;nzcount())</div>
<div class="line">        std::swap(_a, _b);</div>
<div class="line">    SparseMatConstIterator_&lt;float&gt; it = _a-&gt;begin&lt;<span class="keywordtype">float</span>&gt;(),</div>
<div class="line">                                   it_end = _a-&gt;end&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line">    <span class="keywordtype">double</span> ccorr = 0;</div>
<div class="line">    <span class="keywordflow">for</span>(; it != it_end; ++it)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// take the next element from the first matrix</span></div>
<div class="line">        <span class="keywordtype">float</span> avalue = *it;</div>
<div class="line">        <span class="keyword">const</span> Node* anode = it.node();</div>
<div class="line">        <span class="comment">// and try to find an element with the same index in the second matrix.</span></div>
<div class="line">        <span class="comment">// since the hash value depends only on the element index,</span></div>
<div class="line">        <span class="comment">// reuse the hash value stored in the node</span></div>
<div class="line">        <span class="keywordtype">float</span> bvalue = _b-&gt;value&lt;<span class="keywordtype">float</span>&gt;(anode-&gt;idx,&amp;anode-&gt;hashval);</div>
<div class="line">        ccorr += avalue*bvalue;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> ccorr;</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ul>
</div><h2 class="groupheader">Определения типов</h2>
<a id="a4f7803d5c41eef808081903167d3a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7803d5c41eef808081903167d3a263">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a> <a class="el" href="classcv_1_1_sparse_mat.html#a4f7803d5c41eef808081903167d3a263">cv::SparseMat::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa766accd9ac415bea90019010f58cac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa766accd9ac415bea90019010f58cac6">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a> <a class="el" href="classcv_1_1_sparse_mat.html#aa766accd9ac415bea90019010f58cac6">cv::SparseMat::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Перечисления</h2>
<a id="ac1661965352d76357d8ecd5cb496026e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1661965352d76357d8ecd5cb496026e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Элементы перечислений</th></tr><tr><td class="fieldname"><a id="ac1661965352d76357d8ecd5cb496026ea14d02d4adbcb5fa71d1922ceda241e8a"></a>MAGIC_VAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac1661965352d76357d8ecd5cb496026eabe1aff4cd2b540afd5a3f4ffca3bd9a2"></a>MAX_DIM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac1661965352d76357d8ecd5cb496026ea28ca477c8ed1afabd0da753827149eeb"></a>HASH_SCALE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac1661965352d76357d8ecd5cb496026ea79cfd2c6ddc2c192623e8426429d27d1"></a>HASH_BIT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Конструктор(ы)</h2>
<a id="a9b5f1214a43144122b158c354a93e338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5f1214a43144122b158c354a93e338">&#9670;&nbsp;</a></span>SparseMat() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::SparseMat::SparseMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various <a class="el" href="classcv_1_1_sparse_mat.html" title="The class SparseMat represents multi-dimensional sparse numerical arrays.">SparseMat</a> constructors. </p>

</div>
</div>
<a id="a62224fe4fbdc6134d80861a150e01b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62224fe4fbdc6134d80861a150e01b58">&#9670;&nbsp;</a></span>SparseMat() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::SparseMat::SparseMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Эта функция перегружена и предоставляется исключительно для удобства использования. Она отличается от вышеупомянутой только фактическими аргументами. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Array dimensionality. </td></tr>
    <tr><td class="paramname">_sizes</td><td>Sparce matrix size on all dementions. </td></tr>
    <tr><td class="paramname">_type</td><td>Sparse matrix data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a753add6192d4355c04e6e3594ab97b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753add6192d4355c04e6e3594ab97b49">&#9670;&nbsp;</a></span>SparseMat() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::SparseMat::SparseMat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Эта функция перегружена и предоставляется исключительно для удобства использования. Она отличается от вышеупомянутой только фактическими аргументами. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted to sparse representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9432a94bda00c7fd2103bcd57654d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9432a94bda00c7fd2103bcd57654d03">&#9670;&nbsp;</a></span>SparseMat() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::SparseMat::SparseMat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Эта функция перегружена и предоставляется исключительно для удобства использования. Она отличается от вышеупомянутой только фактическими аргументами. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted to sparse representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1903162ea8588b8dd0c4421824f8dd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1903162ea8588b8dd0c4421824f8dd9d">&#9670;&nbsp;</a></span>~SparseMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::SparseMat::~SparseMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the destructor </p>

</div>
</div>
<h2 class="groupheader">Методы</h2>
<a id="a8d1d03d3c19ccd8cd5653b3b7375bb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1d03d3c19ccd8cd5653b3b7375bb68">&#9670;&nbsp;</a></span>addref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::addref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>manually increments the reference counter to the header. </p>

</div>
</div>
<a id="ae102ac11f15a875d9b689575d585d21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae102ac11f15a875d9b689575d585d21f">&#9670;&nbsp;</a></span>assignTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::assignTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3913621631f1f3bd6a3a3ef6e667570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3913621631f1f3bd6a3a3ef6e667570">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a> cv::SparseMat::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the sparse matrix iterator at the matrix beginning </p>
<p>return the sparse matrix iterator pointing to the first sparse matrix element </p>

</div>
</div>
<a id="af371f2cb6952b62ec7ad3b82538d9363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af371f2cb6952b62ec7ad3b82538d9363">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt;_Tp&gt; cv::SparseMat::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the sparse matrix iterator at the matrix beginning </p>

</div>
</div>
<a id="a106056c6a53a49929da7c52c24945165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106056c6a53a49929da7c52c24945165">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a> cv::SparseMat::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the read-only sparse matrix iterator at the matrix beginning </p>

</div>
</div>
<a id="ad02b25e131308553618b710e22ca8af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02b25e131308553618b710e22ca8af1">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt;_Tp&gt; cv::SparseMat::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the read-only sparse matrix iterator at the matrix beginning </p>

</div>
</div>
<a id="acb6b3b831a74b2071f8741ee873e925f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6b3b831a74b2071f8741ee873e925f">&#9670;&nbsp;</a></span>channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> cv::SparseMat::channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of channels </p>

</div>
</div>
<a id="a2fa705d84961513f6e0b0066ec245a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa705d84961513f6e0b0066ec245a8e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets all the sparse matrix elements to 0, which means clearing the hash table. </p>

</div>
</div>
<a id="a230a36b59925a5e300a703ae1186856b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230a36b59925a5e300a703ae1186856b">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> cv::SparseMat::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates full copy of the matrix </p>

</div>
</div>
<a id="a668825b1d0bb87a075cc2382692093b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668825b1d0bb87a075cc2382692093b7">&#9670;&nbsp;</a></span>convertTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts sparse matrix to dense n-dim matrix with optional type conversion and scaling. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>- output matrix; if it does not have a proper size or type before the operation, it is reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rtype</td><td>- desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>- optional scale factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>- optional delta added to the scaled values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a577ea9bbc02ffcf195df6d96f9c9650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577ea9bbc02ffcf195df6d96f9c9650c">&#9670;&nbsp;</a></span>convertTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type </p>

</div>
</div>
<a id="a6b077b6ec96d3aa588ef32e63cd7f7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b077b6ec96d3aa588ef32e63cd7f7f5">&#9670;&nbsp;</a></span>copyTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts sparse matrix to dense matrix. </p>

</div>
</div>
<a id="a18d9fb50fa768fd20e9f11b003906133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d9fb50fa768fd20e9f11b003906133">&#9670;&nbsp;</a></span>copyTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copies all the data to the destination matrix. All the previous content of m is erased </p>

</div>
</div>
<a id="adf2713a5ec1fb025c9ff4014a53e68c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2713a5ec1fb025c9ff4014a53e68c6">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reallocates sparse matrix. </p>
<p>If the matrix already had the proper size and type, it is simply cleared with <a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e" title="sets all the sparse matrix elements to 0, which means clearing the hash table.">clear()</a>, otherwise, the old matrix is released (using <a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">release()</a>) and the new one is allocated. </p>

</div>
</div>
<a id="ae40e39e851f00341f1df57cb482429dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40e39e851f00341f1df57cb482429dc">&#9670;&nbsp;</a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> cv::SparseMat::depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the depth of sparse matrix elements </p>

</div>
</div>
<a id="a1779da985ecb9cd570e0dd71a49b6aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1779da985ecb9cd570e0dd71a49b6aca">&#9670;&nbsp;</a></span>dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> cv::SparseMat::dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the matrix dimensionality </p>

</div>
</div>
<a id="af42f343f4f3d5bc974db1eca57417150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42f343f4f3d5bc974db1eca57417150">&#9670;&nbsp;</a></span>elemSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> cv::SparseMat::elemSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts sparse matrix to the old-style representation; all the elements are copied. </p>
<p>returns the size of each element in bytes (not including the overhead - the space occupied by <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html" title="sparse matrix node - element of a hash table">SparseMat::Node</a> elements) </p>

</div>
</div>
<a id="a3564e3c77b19ac1104dbe924973dd288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3564e3c77b19ac1104dbe924973dd288">&#9670;&nbsp;</a></span>elemSize1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> cv::SparseMat::elemSize1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <a class="el" href="classcv_1_1_sparse_mat.html#af42f343f4f3d5bc974db1eca57417150" title="converts sparse matrix to the old-style representation; all the elements are copied.">elemSize()</a>/channels() </p>

</div>
</div>
<a id="a71cef837db3fd9aabef3abb57ae19a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cef837db3fd9aabef3abb57ae19a1b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a> cv::SparseMat::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the sparse matrix iterator at the matrix end </p>
<p>return the sparse matrix iterator pointing to the element following the last sparse matrix element </p>

</div>
</div>
<a id="a4fe2ca854bcafa54cb371146523c7e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe2ca854bcafa54cb371146523c7e36">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt;_Tp&gt; cv::SparseMat::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the typed sparse matrix iterator at the matrix end </p>

</div>
</div>
<a id="a4d3e2d01ec6a363488097ae2b0b3c124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3e2d01ec6a363488097ae2b0b3c124">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a> cv::SparseMat::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the read-only sparse matrix iterator at the matrix end </p>

</div>
</div>
<a id="ac004c4119d6e77bfa95e803d9a7dd5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac004c4119d6e77bfa95e803d9a7dd5fd">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt;_Tp&gt; cv::SparseMat::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the typed read-only sparse matrix iterator at the matrix end </p>

</div>
</div>
<a id="a6f64485a3f47ba79847a3fdf349b9943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f64485a3f47ba79847a3fdf349b9943">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erases the specified element (nD case) </p>

</div>
</div>
<a id="ab00d2c0c7bff3c631d1ac43fe1be45cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00d2c0c7bff3c631d1ac43fe1be45cd">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erases the specified element (3D case) </p>

</div>
</div>
<a id="ad4ff041a2a3771613847b94c761ab1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ff041a2a3771613847b94c761ab1f4">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erases the specified element (2D case) </p>

</div>
</div>
<a id="a6a68ed5f9b65fa36c3d209c0dafa24a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a68ed5f9b65fa36c3d209c0dafa24a8">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::SparseMat::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (nD case) </p>

</div>
</div>
<a id="aca75a3e5266b78bafcd01dffe75e563d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca75a3e5266b78bafcd01dffe75e563d">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::SparseMat::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (3D case) </p>

</div>
</div>
<a id="a782dd472d4a859a13dc77fca7e4ef8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782dd472d4a859a13dc77fca7e4ef8a6">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::SparseMat::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (2D case) </p>

</div>
</div>
<a id="af31f0f8c0f55db0640aa8081a593f64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f0f8c0f55db0640aa8081a593f64e">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::SparseMat::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (1D case) </p>
<p>Return pointer to the specified sparse matrix element if it exists</p>
<p><code>find&lt;_Tp&gt;(i0,...[,hashval])</code> is equivalent to <code>(_const Tp*)ptr(i0,...false[,hashval])</code>.</p>
<p>If the specified element does not exist, the methods return NULL. </p>

</div>
</div>
<a id="a5c4f02569b2b2f183903112435a13f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4f02569b2b2f183903112435a13f83">&#9670;&nbsp;</a></span>hash() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> cv::SparseMat::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the element hash value (nD case) </p>

</div>
</div>
<a id="ae882e4ed31b4cc76b19cd67d84e854b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae882e4ed31b4cc76b19cd67d84e854b1">&#9670;&nbsp;</a></span>hash() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> cv::SparseMat::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the element hash value (1D case) </p>

</div>
</div>
<a id="aa9aba486fd7e4fc2b1c80bc54844ac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9aba486fd7e4fc2b1c80bc54844ac23">&#9670;&nbsp;</a></span>hash() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> cv::SparseMat::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the element hash value (2D case) </p>

</div>
</div>
<a id="a681b6dafd842a95589cb82ed790279c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681b6dafd842a95589cb82ed790279c9">&#9670;&nbsp;</a></span>hash() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> cv::SparseMat::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the element hash value (3D case) </p>

</div>
</div>
<a id="acfbf3c27ab6d5f90e4d37b1654f90f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbf3c27ab6d5f90e4d37b1654f90f0a">&#9670;&nbsp;</a></span>newNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* cv::SparseMat::newNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>hashval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a499f156a1dc912aae86f1d725fbb9b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499f156a1dc912aae86f1d725fbb9b77">&#9670;&nbsp;</a></span>node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a>* cv::SparseMat::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>nidx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3e934620dcbc6248a09e2b8a5760b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e934620dcbc6248a09e2b8a5760b3f">&#9670;&nbsp;</a></span>node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a>* cv::SparseMat::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>nidx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0cd6ef01802341dda3e8b75af5933f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cd6ef01802341dda3e8b75af5933f0">&#9670;&nbsp;</a></span>nzcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> cv::SparseMat::nzcount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of non-zero elements (=the number of hash table nodes) </p>

</div>
</div>
<a id="a9e634f2d73a077444df4395e50821129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e634f2d73a077444df4395e50821129">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a>&amp; cv::SparseMat::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>equivalent to the corresponding constructor </p>

</div>
</div>
<a id="a144c0f1ec1d3ffc20305bc4d1747b741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c0f1ec1d3ffc20305bc4d1747b741">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a>&amp; cv::SparseMat::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assignment operator. This is O(1) operation, i.e. no data is copied </p>

</div>
</div>
<a id="a5425bac965f62767f50c7e68a7c452a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5425bac965f62767f50c7e68a7c452a0">&#9670;&nbsp;</a></span>ptr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* cv::SparseMat::ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (nD case) </p>

</div>
</div>
<a id="a810b96cf23e3cc816e7f99473b81b513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810b96cf23e3cc816e7f99473b81b513">&#9670;&nbsp;</a></span>ptr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* cv::SparseMat::ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (1D case) </p>
<p>specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case. return pointer to the matrix element.</p><ul>
<li>if the element is there (it's non-zero), the pointer to it is returned</li>
<li>if it's not there and createMissing=false, NULL pointer is returned</li>
<li>if it's not there and createMissing=true, then the new element is created and initialized with 0. Pointer to it is returned</li>
<li>if the optional hashval pointer is not NULL, the element hash value is not computed, but *hashval is taken instead. </li>
</ul>

</div>
</div>
<a id="a14e7bb6106e6b4608ddbbc394bbf585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e7bb6106e6b4608ddbbc394bbf585e">&#9670;&nbsp;</a></span>ptr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* cv::SparseMat::ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (2D case) </p>

</div>
</div>
<a id="afa0e9b6331a781f1d746e77582bee8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0e9b6331a781f1d746e77582bee8a8">&#9670;&nbsp;</a></span>ptr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* cv::SparseMat::ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns pointer to the specified element (3D case) </p>

</div>
</div>
<a id="a31eeb43c5070301db9cba23bdb45ee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eeb43c5070301db9cba23bdb45ee11">&#9670;&nbsp;</a></span>ref() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; cv::SparseMat::ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns reference to the specified element (nD case) </p>

</div>
</div>
<a id="a8123bdba2899184e4946c82b2ddaa541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8123bdba2899184e4946c82b2ddaa541">&#9670;&nbsp;</a></span>ref() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; cv::SparseMat::ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns reference to the specified element (3D case) </p>

</div>
</div>
<a id="a565a2111e6223af3d3e7d7af2db7588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565a2111e6223af3d3e7d7af2db7588b">&#9670;&nbsp;</a></span>ref() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; cv::SparseMat::ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns reference to the specified element (2D case) </p>

</div>
</div>
<a id="a0e1e95540e8cc75976bb4be97dc2203e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1e95540e8cc75976bb4be97dc2203e">&#9670;&nbsp;</a></span>ref() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; cv::SparseMat::ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns reference to the specified element (1D case) </p>
<p>return read-write reference to the specified sparse matrix element.</p>
<p><code>ref&lt;_Tp&gt;(i0,...[,hashval])</code> is equivalent to <code>*(_Tp*)ptr(i0,...,true[,hashval])</code>. The methods always return a valid reference. If the element did not exist, it is created and initialized with 0. </p>

</div>
</div>
<a id="a3f4c162afd8cc809d23bd0fe9b38ead7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4c162afd8cc809d23bd0fe9b38ead7">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5adcb69ee679da35f74ea3a78594a692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adcb69ee679da35f74ea3a78594a692">&#9670;&nbsp;</a></span>removeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::removeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>hidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>previdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af86523883daef3f618a7ec38fe049edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86523883daef3f618a7ec38fe049edc">&#9670;&nbsp;</a></span>resizeHashTab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> cv::SparseMat::resizeHashTab </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65eac830987646a4792815ad4e717c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65eac830987646a4792815ad4e717c3e">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>* cv::SparseMat::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the array of sizes, or NULL if the matrix is not allocated </p>

</div>
</div>
<a id="a4fe9c986b3cf0240c68ce985df334c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe9c986b3cf0240c68ce985df334c17">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> cv::SparseMat::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the size of i-th matrix dimension (or 0) </p>

</div>
</div>
<a id="a3331bffc1409d61631d223169a950b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3331bffc1409d61631d223169a950b25">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> cv::SparseMat::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns type of sparse matrix elements </p>

</div>
</div>
<a id="af112d88b293cd922392043fd57bb8398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af112d88b293cd922392043fd57bb8398">&#9670;&nbsp;</a></span>value() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp cv::SparseMat::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns value of the specified element (nD case) </p>

</div>
</div>
<a id="a39e257c6ec922968175136de3f572d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e257c6ec922968175136de3f572d2f">&#9670;&nbsp;</a></span>value() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp&amp; cv::SparseMat::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the value stored in the sparse martix node </p>

</div>
</div>
<a id="a34720d97d1db6e1f57ab229fddb5281f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34720d97d1db6e1f57ab229fddb5281f">&#9670;&nbsp;</a></span>value() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp cv::SparseMat::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns value of the specified element (3D case) </p>

</div>
</div>
<a id="a50920170695fb08a34b4dbfd272b352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50920170695fb08a34b4dbfd272b352d">&#9670;&nbsp;</a></span>value() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp cv::SparseMat::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns value of the specified element (2D case) </p>

</div>
</div>
<a id="a64d526ae50a7aceb49b2c5ba3528c859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d526ae50a7aceb49b2c5ba3528c859">&#9670;&nbsp;</a></span>value() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp cv::SparseMat::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns value of the specified element (1D case) </p>
<p>return value of the specified sparse matrix element.</p>
<p><code>value&lt;_Tp&gt;(i0,...[,hashval])</code> is equivalent to </p><div class="fragment"><div class="line">{ <span class="keyword">const</span> _Tp* p = find&lt;_Tp&gt;(i0,...[,hashval]); <span class="keywordflow">return</span> p ? *p : _Tp(); }</div>
</div><!-- fragment --><p>That is, if the element did not exist, the methods return 0. </p>

</div>
</div>
<a id="a0ede1a78ef553729dd33f039c1ed50f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ede1a78ef553729dd33f039c1ed50f5">&#9670;&nbsp;</a></span>value() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; cv::SparseMat::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the value stored in the sparse martix node </p>

</div>
</div>
<h2 class="groupheader">Данные класса</h2>
<a id="ad5f261bc8c1330e4e516684861410cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f261bc8c1330e4e516684861410cd2">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ae4ef4b83c54acc5e8d2956db165de790">int</a> cv::SparseMat::flags</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3741ff43acd46b31aace23dee092d85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3741ff43acd46b31aace23dee092d85a">&#9670;&nbsp;</a></span>hdr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a>* cv::SparseMat::hdr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li>opencv/build/include/opencv2/core/<a class="el" href="core_2mat_8hpp_source.html">mat.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecv.html">cv</a></li><li class="navelem"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a></li>
    <li class="footer">Создано системой <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0 </li>
  </ul>
</div>
</body>
</html>
