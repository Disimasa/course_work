<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neural Network library: Шаблон класса cv::AutoBuffer&lt; _Tp, fixed_size &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Neural Network library
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">Small lib for neural networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcv_1_1_auto_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Открытые типы</a> &#124;
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="#pro-attribs">Защищенные данные</a> &#124;
<a href="classcv_1_1_auto_buffer-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Шаблон класса cv::AutoBuffer&lt; _Tp, fixed_size &gt;<div class="ingroups"><a class="el" href="group__core.html">Core functionality</a> &raquo; <a class="el" href="group__core__utils.html">Utility and system functions and macros</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Automatically Allocated Buffer Class.  
 <a href="classcv_1_1_auto_buffer.html#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Открытые типы</h2></td></tr>
<tr class="memitem:afbc953161e91d6455882c315eff66f6d"><td class="memItemLeft" align="right" valign="top">typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#afbc953161e91d6455882c315eff66f6d">value_type</a></td></tr>
<tr class="separator:afbc953161e91d6455882c315eff66f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:a990ab2dd088c226def0e59177933c9df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a990ab2dd088c226def0e59177933c9df">AutoBuffer</a> ()</td></tr>
<tr class="memdesc:a990ab2dd088c226def0e59177933c9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default constructor  <a href="classcv_1_1_auto_buffer.html#a990ab2dd088c226def0e59177933c9df">Подробнее...</a><br /></td></tr>
<tr class="separator:a990ab2dd088c226def0e59177933c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac498c6689e5a18843e1c9d23441c3a99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#ac498c6689e5a18843e1c9d23441c3a99">AutoBuffer</a> (<a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> _size)</td></tr>
<tr class="memdesc:ac498c6689e5a18843e1c9d23441c3a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor taking the real buffer size  <a href="classcv_1_1_auto_buffer.html#ac498c6689e5a18843e1c9d23441c3a99">Подробнее...</a><br /></td></tr>
<tr class="separator:ac498c6689e5a18843e1c9d23441c3a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3416e6aa3bb03435706abce813950d6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a3416e6aa3bb03435706abce813950d6e">AutoBuffer</a> (const <a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a>&lt; _Tp, fixed_size &gt; &amp;<a class="el" href="classcv_1_1_auto_buffer.html#a5286c7bfa1926f51f6d0c7bf5e01c001">buf</a>)</td></tr>
<tr class="memdesc:a3416e6aa3bb03435706abce813950d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the copy constructor  <a href="classcv_1_1_auto_buffer.html#a3416e6aa3bb03435706abce813950d6e">Подробнее...</a><br /></td></tr>
<tr class="separator:a3416e6aa3bb03435706abce813950d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8be3a945146d9528f747eafb6c34a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a>&lt; _Tp, fixed_size &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#ad8be3a945146d9528f747eafb6c34a81">operator=</a> (const <a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a>&lt; _Tp, fixed_size &gt; &amp;<a class="el" href="classcv_1_1_auto_buffer.html#a5286c7bfa1926f51f6d0c7bf5e01c001">buf</a>)</td></tr>
<tr class="memdesc:ad8be3a945146d9528f747eafb6c34a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">the assignment operator  <a href="classcv_1_1_auto_buffer.html#ad8be3a945146d9528f747eafb6c34a81">Подробнее...</a><br /></td></tr>
<tr class="separator:ad8be3a945146d9528f747eafb6c34a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310b178f5acd17d7ebf5fb1e8cdc4fc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a310b178f5acd17d7ebf5fb1e8cdc4fc7">~AutoBuffer</a> ()</td></tr>
<tr class="memdesc:a310b178f5acd17d7ebf5fb1e8cdc4fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor. calls <a class="el" href="classcv_1_1_auto_buffer.html#aab78aeff0108ad5ba8c96baafd58702b" title="deallocates the buffer if it was dynamically allocated">deallocate()</a>  <a href="classcv_1_1_auto_buffer.html#a310b178f5acd17d7ebf5fb1e8cdc4fc7">Подробнее...</a><br /></td></tr>
<tr class="separator:a310b178f5acd17d7ebf5fb1e8cdc4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c16dbf31a16748ffc930e796f0dc54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a1c16dbf31a16748ffc930e796f0dc54b">allocate</a> (<a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> _size)</td></tr>
<tr class="memdesc:a1c16dbf31a16748ffc930e796f0dc54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates the new buffer of size _size. if the _size is small enough, stack-allocated buffer is used  <a href="classcv_1_1_auto_buffer.html#a1c16dbf31a16748ffc930e796f0dc54b">Подробнее...</a><br /></td></tr>
<tr class="separator:a1c16dbf31a16748ffc930e796f0dc54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab78aeff0108ad5ba8c96baafd58702b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#aab78aeff0108ad5ba8c96baafd58702b">deallocate</a> ()</td></tr>
<tr class="memdesc:aab78aeff0108ad5ba8c96baafd58702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocates the buffer if it was dynamically allocated  <a href="classcv_1_1_auto_buffer.html#aab78aeff0108ad5ba8c96baafd58702b">Подробнее...</a><br /></td></tr>
<tr class="separator:aab78aeff0108ad5ba8c96baafd58702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97edc51af209cd6ab20da864c3468124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a97edc51af209cd6ab20da864c3468124">resize</a> (<a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> _size)</td></tr>
<tr class="memdesc:a97edc51af209cd6ab20da864c3468124"><td class="mdescLeft">&#160;</td><td class="mdescRight">resizes the buffer and preserves the content  <a href="classcv_1_1_auto_buffer.html#a97edc51af209cd6ab20da864c3468124">Подробнее...</a><br /></td></tr>
<tr class="separator:a97edc51af209cd6ab20da864c3468124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e51a3baa4dcb2d8eaefddc4c3ceb455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a3e51a3baa4dcb2d8eaefddc4c3ceb455">size</a> () const</td></tr>
<tr class="memdesc:a3e51a3baa4dcb2d8eaefddc4c3ceb455"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current buffer size  <a href="classcv_1_1_auto_buffer.html#a3e51a3baa4dcb2d8eaefddc4c3ceb455">Подробнее...</a><br /></td></tr>
<tr class="separator:a3e51a3baa4dcb2d8eaefddc4c3ceb455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4992346bfec9774b2572253a89cdd330"><td class="memItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a4992346bfec9774b2572253a89cdd330">data</a> ()</td></tr>
<tr class="memdesc:a4992346bfec9774b2572253a89cdd330"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the real buffer, stack-allocated or heap-allocated  <a href="classcv_1_1_auto_buffer.html#a4992346bfec9774b2572253a89cdd330">Подробнее...</a><br /></td></tr>
<tr class="separator:a4992346bfec9774b2572253a89cdd330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb4f4459ce4e3969f3b1586bd5092c3"><td class="memItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a2cb4f4459ce4e3969f3b1586bd5092c3">data</a> () const</td></tr>
<tr class="memdesc:a2cb4f4459ce4e3969f3b1586bd5092c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns read-only pointer to the real buffer, stack-allocated or heap-allocated  <a href="classcv_1_1_auto_buffer.html#a2cb4f4459ce4e3969f3b1586bd5092c3">Подробнее...</a><br /></td></tr>
<tr class="separator:a2cb4f4459ce4e3969f3b1586bd5092c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf37a20ae4387196fe2a5684ced410dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#abf37a20ae4387196fe2a5684ced410dc">operator _Tp *</a> ()</td></tr>
<tr class="memdesc:abf37a20ae4387196fe2a5684ced410dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the real buffer, stack-allocated or heap-allocated  <a href="classcv_1_1_auto_buffer.html#abf37a20ae4387196fe2a5684ced410dc">Подробнее...</a><br /></td></tr>
<tr class="separator:abf37a20ae4387196fe2a5684ced410dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1062498f5ea59f2784883cfd6607cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a8e1062498f5ea59f2784883cfd6607cb">operator const _Tp *</a> () const</td></tr>
<tr class="memdesc:a8e1062498f5ea59f2784883cfd6607cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns read-only pointer to the real buffer, stack-allocated or heap-allocated  <a href="classcv_1_1_auto_buffer.html#a8e1062498f5ea59f2784883cfd6607cb">Подробнее...</a><br /></td></tr>
<tr class="separator:a8e1062498f5ea59f2784883cfd6607cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Защищенные данные</h2></td></tr>
<tr class="memitem:a194ac92b66c003787e0782bd8a38750b"><td class="memItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a194ac92b66c003787e0782bd8a38750b">ptr</a></td></tr>
<tr class="memdesc:a194ac92b66c003787e0782bd8a38750b"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the real buffer, can point to buf if the buffer is small enough  <a href="classcv_1_1_auto_buffer.html#a194ac92b66c003787e0782bd8a38750b">Подробнее...</a><br /></td></tr>
<tr class="separator:a194ac92b66c003787e0782bd8a38750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6025c7fd11fa230c2c315673d2d293b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a6025c7fd11fa230c2c315673d2d293b3">sz</a></td></tr>
<tr class="memdesc:a6025c7fd11fa230c2c315673d2d293b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the real buffer  <a href="classcv_1_1_auto_buffer.html#a6025c7fd11fa230c2c315673d2d293b3">Подробнее...</a><br /></td></tr>
<tr class="separator:a6025c7fd11fa230c2c315673d2d293b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5286c7bfa1926f51f6d0c7bf5e01c001"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html#a5286c7bfa1926f51f6d0c7bf5e01c001">buf</a> [(fixed_size &gt; 0) ? fixed_size :1]</td></tr>
<tr class="memdesc:a5286c7bfa1926f51f6d0c7bf5e01c001"><td class="mdescLeft">&#160;</td><td class="mdescRight">pre-allocated buffer. At least 1 element to confirm C++ standard requirements  <a href="classcv_1_1_auto_buffer.html#a5286c7bfa1926f51f6d0c7bf5e01c001">Подробнее...</a><br /></td></tr>
<tr class="separator:a5286c7bfa1926f51f6d0c7bf5e01c001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><h3>template&lt;typename _Tp, size_t fixed_size = 1024/sizeof(_Tp)+8&gt;<br />
class cv::AutoBuffer&lt; _Tp, fixed_size &gt;</h3>

<p>Automatically Allocated Buffer Class. </p>
<p>The class is used for temporary buffers in functions and methods. If a temporary buffer is usually small (a few K's of memory), but its size depends on the parameters, it makes sense to create a small fixed-size array on stack and use it if it's large enough. If the required buffer size is larger than the fixed size, another buffer of sufficient size is allocated dynamically and released after the processing. Therefore, in typical cases, when the buffer size is small, there is no overhead associated with malloc()/free(). At the same time, there is no limit on the size of processed data.</p>
<p>This is what <a class="el" href="classcv_1_1_auto_buffer.html" title="Automatically Allocated Buffer Class.">AutoBuffer</a> does. The template takes 2 parameters - type of the buffer elements and the number of stack-allocated elements. Here is how the class is used:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_func(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html">cv::Mat</a>&amp; m)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer&lt;float&gt;</a> <a class="code" href="classcv_1_1_auto_buffer.html#a5286c7bfa1926f51f6d0c7bf5e01c001">buf</a>(1000); <span class="comment">// create automatic buffer containing 1000 floats</span></div>
<div class="line"> </div>
<div class="line">   <a class="code" href="classcv_1_1_auto_buffer.html#a5286c7bfa1926f51f6d0c7bf5e01c001">buf</a>.allocate(m.<a class="code" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e">rows</a>); <span class="comment">// if m.rows &lt;= 1000, the pre-allocated buffer is used,</span></div>
<div class="line">                         <span class="comment">// otherwise the buffer of &quot;m.rows&quot; floats will be allocated</span></div>
<div class="line">                         <span class="comment">// dynamically and deallocated in cv::AutoBuffer destructor</span></div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="ttc" id="aclasscv_1_1_auto_buffer_html"><div class="ttname"><a href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a></div><div class="ttdoc">Automatically Allocated Buffer Class.</div><div class="ttdef"><b>Definition:</b> utility.hpp:102</div></div>
<div class="ttc" id="aclasscv_1_1_auto_buffer_html_a5286c7bfa1926f51f6d0c7bf5e01c001"><div class="ttname"><a href="classcv_1_1_auto_buffer.html#a5286c7bfa1926f51f6d0c7bf5e01c001">cv::AutoBuffer::buf</a></div><div class="ttdeci">_Tp buf[(fixed_size &gt; 0) ? fixed_size :1]</div><div class="ttdoc">pre-allocated buffer. At least 1 element to confirm C++ standard requirements</div><div class="ttdef"><b>Definition:</b> utility.hpp:150</div></div>
<div class="ttc" id="aclasscv_1_1_mat_html"><div class="ttname"><a href="classcv_1_1_mat.html">cv::Mat</a></div><div class="ttdoc">n-dimensional dense array class</div><div class="ttdef"><b>Definition:</b> mat.hpp:798</div></div>
<div class="ttc" id="aclasscv_1_1_mat_html_abed816466c45234254d25bc59c31245e"><div class="ttname"><a href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e">cv::Mat::rows</a></div><div class="ttdeci">int rows</div><div class="ttdoc">the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions</div><div class="ttdef"><b>Definition:</b> mat.hpp:2092</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Определения типов</h2>
<a id="afbc953161e91d6455882c315eff66f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc953161e91d6455882c315eff66f6d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Tp <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::<a class="el" href="classcv_1_1_auto_buffer.html#afbc953161e91d6455882c315eff66f6d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Конструктор(ы)</h2>
<a id="a990ab2dd088c226def0e59177933c9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990ab2dd088c226def0e59177933c9df">&#9670;&nbsp;</a></span>AutoBuffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::<a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the default constructor </p>

</div>
</div>
<a id="ac498c6689e5a18843e1c9d23441c3a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac498c6689e5a18843e1c9d23441c3a99">&#9670;&nbsp;</a></span>AutoBuffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::<a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor taking the real buffer size </p>

</div>
</div>
<a id="a3416e6aa3bb03435706abce813950d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3416e6aa3bb03435706abce813950d6e">&#9670;&nbsp;</a></span>AutoBuffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::<a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a>&lt; _Tp, fixed_size &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the copy constructor </p>

</div>
</div>
<a id="a310b178f5acd17d7ebf5fb1e8cdc4fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310b178f5acd17d7ebf5fb1e8cdc4fc7">&#9670;&nbsp;</a></span>~AutoBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::~<a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destructor. calls <a class="el" href="classcv_1_1_auto_buffer.html#aab78aeff0108ad5ba8c96baafd58702b" title="deallocates the buffer if it was dynamically allocated">deallocate()</a> </p>

</div>
</div>
<h2 class="groupheader">Методы</h2>
<a id="a1c16dbf31a16748ffc930e796f0dc54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c16dbf31a16748ffc930e796f0dc54b">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates the new buffer of size _size. if the _size is small enough, stack-allocated buffer is used </p>

</div>
</div>
<a id="a4992346bfec9774b2572253a89cdd330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4992346bfec9774b2572253a89cdd330">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Tp* <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns pointer to the real buffer, stack-allocated or heap-allocated </p>

</div>
</div>
<a id="a2cb4f4459ce4e3969f3b1586bd5092c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb4f4459ce4e3969f3b1586bd5092c3">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns read-only pointer to the real buffer, stack-allocated or heap-allocated </p>

</div>
</div>
<a id="aab78aeff0108ad5ba8c96baafd58702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab78aeff0108ad5ba8c96baafd58702b">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deallocates the buffer if it was dynamically allocated </p>

</div>
</div>
<a id="abf37a20ae4387196fe2a5684ced410dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf37a20ae4387196fe2a5684ced410dc">&#9670;&nbsp;</a></span>operator _Tp *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::operator _Tp * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns pointer to the real buffer, stack-allocated or heap-allocated </p>

</div>
</div>
<a id="a8e1062498f5ea59f2784883cfd6607cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1062498f5ea59f2784883cfd6607cb">&#9670;&nbsp;</a></span>operator const _Tp *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::operator const _Tp * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns read-only pointer to the real buffer, stack-allocated or heap-allocated </p>

</div>
</div>
<a id="ad8be3a945146d9528f747eafb6c34a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8be3a945146d9528f747eafb6c34a81">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a>&lt;_Tp, fixed_size&gt;&amp; <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a>&lt; _Tp, fixed_size &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the assignment operator </p>

</div>
</div>
<a id="a97edc51af209cd6ab20da864c3468124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97edc51af209cd6ab20da864c3468124">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__highgui__c.html#gad1f9461adaad33556b3a01c7f2c6ceab">void</a> <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a>&#160;</td>
          <td class="paramname"><em>_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>resizes the buffer and preserves the content </p>

</div>
</div>
<a id="a3e51a3baa4dcb2d8eaefddc4c3ceb455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e51a3baa4dcb2d8eaefddc4c3ceb455">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current buffer size </p>

</div>
</div>
<h2 class="groupheader">Данные класса</h2>
<a id="a5286c7bfa1926f51f6d0c7bf5e01c001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5286c7bfa1926f51f6d0c7bf5e01c001">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::buf[(fixed_size &gt; 0) ? fixed_size :1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pre-allocated buffer. At least 1 element to confirm C++ standard requirements </p>

</div>
</div>
<a id="a194ac92b66c003787e0782bd8a38750b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194ac92b66c003787e0782bd8a38750b">&#9670;&nbsp;</a></span>ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Tp* <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the real buffer, can point to buf if the buffer is small enough </p>

</div>
</div>
<a id="a6025c7fd11fa230c2c315673d2d293b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6025c7fd11fa230c2c315673d2d293b3">&#9670;&nbsp;</a></span>sz</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , size_t fixed_size = 1024/sizeof(_Tp)+8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime_2autogenerated_2opencl__core_8hpp.html#a6ff403ead16f7faa1f7228274eb6b01d">size_t</a> <a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer</a>&lt; _Tp, fixed_size &gt;::sz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>size of the real buffer </p>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li>opencv/build/include/opencv2/core/<a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecv.html">cv</a></li><li class="navelem"><a class="el" href="classcv_1_1_auto_buffer.html">AutoBuffer</a></li>
    <li class="footer">Создано системой <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0 </li>
  </ul>
</div>
</body>
</html>
